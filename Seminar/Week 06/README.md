<h1>Предефиниране на оператори. Приятелски класове и функции. Mutable полета.</h1>

<h3>Oператори</h3>

<h5>Видове оператори:</h5>
в C++ има два вида оператори:

- Унарни (на един аргумент)
- Бинарни (на два аргумента)

<h5>Операторите се характеризират с:</h5>

- Приоритет
- Асоциативност
- Позиция на оператора спярмо аргумента - *префиксен*, *инфиксен* и *суфиксен*

<h5>Списъка на операторите в C++:</h5>

| Оператор                                       | Асоциативност                   |
|------------------------------------------------|---------------------------------|
| () [] -> . ++ --                               |      лявоасоциативен       	   |
|  + - ! ~ ++ -- (type)* & sizeof                |      дясноасоциативен      	   |
| * / %                                          |		лявоасоциативен     	   |
|  + -        									 |      лявоасоциативен			   |
|    << >>      								 |      лявоасоциативен			   |
|  <  <=  >  >=         						 |      лявоасоциативен			   |
|    ==  !=       								 |      лявоасоциативен			   |
|      &     									 |     	лявоасоциативен			   |
|     ^      									 |     	лявоасоциативен			   |
|      \|     									 |      лявоасоциативен			   |
|       &&    									 |      лявоасоциативен			   |
|      \|\|     								 |      лявоасоциативен			   |
|      ?:    									 |      дясноасоциативен           |
|     =  +=  -=  *=  /=  %=  >>=  <<=  &=  ^=    |      дясноасоциативен           |

<h5>Рестрикции:</h5>

- Операторите: :: (scope resolution), . (member access), .* (member access through pointer to member) и ?: (ternary conditional) не могат да се предефинират.
- Нови оператори като: **, <>, или &|, не могат да бъдат създадени.
- Не е възможно да се променят приоритета, групирането или броя на операндите на операторите.
- Предефинирането на оператора -> трябва или да върне обикновен указател, или да върне обект (по референция или по стойност), за който операторът -> на свой ред е предефиниран.

<h3>Пример за предефиниране на оператор:</h3>

```c++
Complex& Complex::operator+=(const Complex& other)
{
	real += other.real;
	im += other.im;
	return *this;
}
```

<h5>Вече може да правим следното:</h5>

```c++
int main()
{
	Complex c(1,3); //1 + 3i;
	Complex c2(10,20) // 10 + 2i;
	c += c2 // now c is 11 + 5i
}
```

<h3>Оператори за вход и изход</h3>

Предефинирането на **operator>>** и **operator<<**, които респективно взимат обекти от тип **std::istream&** и **std::ostream&** като лявостоящи аргументи, се наричат оператор за извличане и оператор за вмъкване. Тъй като те взимат потребителски дефиниран тип, като десен аргумент, те **трябва** да се имплементират, като външни функции.

```c++
std::ostream& operator<<(std::ostream& os, const T& obj)
{
    // write obj to stream
    return os;
}

std::istream& operator>>(std::istream& is, T& obj)
{
    // read obj from stream
    if( /* T could not be constructed */ )
        is.setstate(std::ios::failbit);
    return is;
}
```

Тези оператори понякога се имплементират и като приятелски функции.

<h3>Приятелски класове и приятелски функции</h3>

Декларират се с на запазената дума **friend** пред прототипа на функцията.  
Даденият friend-клас/фунцкия има достъп до всички компоненти на класа. 
Т.е. всички членове на класа са public за friend-класовете/функциите приятели.

<h5>Пример за приятелски функции:</h5>

```c++
class Complex
{

private:
	double real;
	double im;
public:
	friend double getModulos(const Complex& other);
	.
	.
	.
}

double getModulos(const Complex& other)
{
	return sqrt((other.real – other.real) * (other.real – other.real) + (other.im – other.im ) * (other.im – other.im));
}
```

<h3>Mutable</h3>

Спецификатора mutable е приложен само в С++. Той позволява на член на обект да предефинира константността. Така mutable член на const обект не е const и може да бъде изменян.

```c++
struct Test
{
private:
	mutable int n;
public:
	void f() const
	{
		n++;
	}

};

int main()
{
	const Test t;
	t.f();
}
```

<h3>Домашно</h3>

**!!!Важно!!!**
Нека домашните да се качват в [този](https://drive.google.com/drive/folders/1t6Zqfk5bGzzl8G2Z5mIfVSm6WiA4QU6A?usp=sharing) drive.

**Задача 1:** Реализирайте клас **Nvector**, който ще се използва за работа с математически вектор. Предефинирайте оператори със следната функционалност:

- Събиране на вектори.
- Изваждане на вектори.
- Умножение на вектор със скалар.
- Проверка дали два вектора са успоредни.
- Проверка дали два вектора са перпендикулярни.
- Взимане на дължина на вектор.
- Достъп до произволен елемент на вектор.
- Вход и изход от потоци.

```c++
int main()
{
	Nvector v(4);
	cin >> v;

	Nvector v2(4);
	cin >> v;

	Nvector result = v + v2;
	cout << result << endl;
}
```

Релизирайте клас двумерната декартова координатна система, която приема 2 вектора, които са нейният базис. Реализрайте следните функции:

- Връща вектор в базиса по подадени 2 координата.
- По подаден вектор връща координатите му в базиса.
 
```c++
int main()
{
	Nvector v(4);
	v[0] = 2;
	v[1] = 1;
	
	Nvector v2(4);
	v2[0] = 3;
	v2[1] = 1;
	
	twoDimCoordSystem s(v1, v2);
	
	cout << s1.getVectorByCoordinates(7, 4); // [26, 11]

	cout << s1.getCoordinatesByVector(7, 4); // [5, -1]

	cout << result << endl;
}
```
 
**Задача 2:** Реализирайте клас **ComplexNumber**, който ще се използва за работа с комплексни числа. Предефинирайте оператори със следната функционалност:

- Събиране на комплексни числа.
- Изваждане на комплексни числа.
- Умножение на комплексни числа.
- Деление на комплексни числа
- Вход и изход от потоци.

```c++
int main()
{
	ComplexNumber c;
	cin >> c;

	ComplexNumber c2;
	cin >> c2;

	ComplexNumber result = c2 / c;

	cout << result << endl;
}
```

**Задача 3:** Релизирайте клас - множество(**без повторение**) от думи от малки/главни латински букви и цифри. В колекцията ви търсенето трябва да е с логаритмична сложност. Предефинирайте оператори:
 
- += и +. Събиране на две колекции.
- -= и -. От думите на лявата колекция, се премахват тези, които участват в дясната.
- [], който приема дума и връща дали стрингът е в колекцията (очакваме логаритмично време).
- *= за добавяне на дума
- /= за премахване на дума.
- << (поток за изход. Отпечатва всички думи в сортиран вид).
- \>\> (поток за вход. Приема думa, която да се добави в речника).

**Важно!** Копирането на стрингове е бавна операция! Помислете как да организирате данните, за да имате логаритмично търсене на дума и при добавяне на нова дума да правите **минимален брой копирания** на стрингове!

```c++
int main()
{
	StringPool dict;
	((dict *= "Ivan") *= "Petur") *= "Alex";
	std::cout << dict << std::endl; // {Alex, Ivan, Petur}
	std::cout << dict["Alex"] << " " << dict["abc"] << std::endl; // 1 0

	StringPool dict2;
	((dict2 *= "Zebra") *= "Alex");

	StringPool result = dict + dict2;
	std::cout << result << std::endl; // {Alex, Ivan, Petur, Zebra}

	StringPool result2 = dict - dict2;
	std::cout << result2 << std::endl; // {Ivan, Petur}

	"NewWOrd" >> result2;
	result2 /= "NonExistingWord";
		std::cout << result2 << std::endl;  //{Ivan, NewWOrd, Petur}
	"Job" >> result2; 
	std::cout << result2 << std::endl;  //{Ivan, Job, NewWOrd, Petur}
}
```