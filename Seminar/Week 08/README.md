<h1>Изключения. Move семантики. Композиция на обекти.</h1>

<h3>Изключения</h3>

`throw` терминира програмата след като "хвърля" аргумента, който го следва.

```c++
int main()
{
    throw 20; // terminate called after throwing an instance of 'int'
}
```

<h3>try & catch</h3>

- В try блока пишем код който потенциално може да хвърли грешка.
- В catch блока хващаме грешките хвърлени от try блока и ги обработваме.

Можем да слагаме няколко catch блока един след друг с различни параметри.
Като накрая можем да сложим блокът `catch(...)`, който хваща всички останали изключения.

```c++
#include <iostream>

int main(){
    try
    {
        throw 20;
    }
    catch(int e)
    {
        std::cout << "Exception occurred excption code: " << e << '\n';
    }
    catch(char const *c)
    {
        std::cout << "Exception occurred: " << e << '\n';
    }
	catch(...)
	{
        std::cout << "Exception occurred!\n";
	}
}
```

<h3>Видове грешки</h3>

Стандартната библиотека за грешки `exception`. В нея има различни видове грешки, които можете да разгледате [тук](https://en.cppreference.com/w/cpp/error/exception).

```c++
#include <iostream>
#include <exception>

int main()
{
    try
    {
        throw std::invalid_argument("Exception occurred");
    }
    catch(const std::invalid_argument &e)
    {
        std::cerr << e.what() << '\n';
    }
}
```

<h3>lvalue vs rvalue</h3>

- **lvalue** - обект, който заема някакво конкретно място в паметта. (стойността в паметта може да се модифицира)
- **rvalue** - обект, който не е  *lvalue* .

<h5>Подаване на стойност по rvalue:</h5>

```c++
#include <iostream>
using std::cout;

void f(int& n)
{
	cout << n << endl;
}
int main()
{
	int number = 10;
	f(number); // OK!
	f(3);      // Error!
}
```
"Висящата" константа 3 **няма адрес в паметта**. За това подаването и като параметър на функцията f ще доведе до компилационна грешка. 

**&&** - за стойности без адрес в паметта

<h5>Пример за използването на lvalue:</h5>

```c++
#include<iostream>
using std::cout;

void f(int&& n)
{
	cout << n << endl;
}
int main()
{
	int number = 10;
	f(number); // Error!
	f(3);      // OK!
}
```

Тук грешката възниква при подаването на променлива, която **има адрес в паметта**.

<h3>Излишни копия?</h3>

Да разгледаме следният програмен фрагмент:
 
```c++
#include<iostream>
#include "Person.h"

Person createPerson(const char* name, int age)
{
	Person p(name, age);
	return p;
}

int main()
{
	Person p2("Petur",18);
	p2 = createPerson("Ivan", 23);
}
```

Тук се изпълняват следните функции на Person:

1. Конструктор на Person (за p2).
2. Конструктор за Person (на p).
3. Копиращ конструктор (за *return p*).
4. Деструктор (в края на функцията *createPerson*).
5. Оператор = (за *p2 = create...* ).
6. Деструктор (в края на функцията *main*).

Проблемът тук е, че правим излишни копия.  Обектът създаден в *createPerson* **се копира два пъти докато се присвои** на p2.

<h3>Move конструктор и move оператор =</h3>

За да избегнем излишните копия, може да "преместим" данните на обектът, който се създава във функцията, в данните на p2.

```c++
//Move constructor
Person::Person(Person&& rhs)
{
	name = rhs.name;
	age = rhs.age;

	rhs.name = nullptr;
}

//Move operator=
Person& Person::operator=(Person&& rhs)
{
	if (this != &rhs)
	{
		free();

		name = rhs.name;
		age = rhs.age;
		rhs.name = nullptr;
	}
	return *this;
}
```
 
Важно е да се обърне внимание, че тук данните **не се копират**, а се **местят**. Т.е приемаме, че rhs **няма да се използва след изпълнението на функцията**.

Сега при изпълнението на първоначално разгледания код:

1. Конструктор на Person (за p2).
2. Конструктор за Person (на p).
3. **Move конструктор** (за *return p*)
4. Деструктор (в края на функцията *createPerson*).
5. **Move oператор =** (за *p2 = create...* ).
6. Деструктор (в края на функцията *main*).

Т.е. тук си спестихме 2 копия за динамичната памет в Person.

<h3>Композиция</h3>

Композиция – класове като елементи на други класове (влагане на класове). Един клас може да включва в себе си обекти от други класове като полета. Когато обект от даден клас се дефинира, автоматично се извиква неговият конструктор. Ако класът съдържа полета, в неговия конструктор трябва да се укаже кои конструктори на полетата да се извикват.

<h5>Пример 1:</h5>

```c++
class A
{
	.
	.
	.
}
class B
{
	 int n;
	 A obj;
}
```

В тази ситуация се извикват **default** конструкторите на n и obj.

<h5>Пример 2:</h5>

```c++
class A
{
	A(int a, int b)
	.
	.
	.
}
class B
{
	B() : A(1, 2){}
	
	int n;
	A obj;
}
```

Тук A няма default-ен конструктор. Това означава, че в конструктора на B трябва да се извика **експлицитно** някой от неговите конструктори.

<h3>Композиция на обекти с динамична памет</h3>

Когато имаме композиция и в главния клас има динамично заделяне на памет, то трябва в реализацията на копи-конструктора и оператор=  **експлицитно** да се извикват копи-конструкторите и оператор= за всички полета (композирани обекти).

```c++
class B;

class A
{
	void copyFrom(A const &other)
	{
		arr = new int[other.size];
		for (int i = 0; i < other.size; i++)
			arr[i] = other.arr[i];
		size = other.size;
	}
	void free()
	{
		delete[] arr;
	}

public:
	B nestedObject;
	int* arr; //dynamic array
	size_t size; 
  
	A(int n) : size(n)
	{
		arr = new int[n];
	}
	A(const A& other) : nestedObject(other.objTest), size(other.size)
	{
		copyFrom(other);
	}
	A& operator=(const A& other)
	{
		
		if (this != &other)
		{
			free();
			nestedObject = other.nestedObject;
			size = other.size;
			copyFrom(other);
		}
		return *this;
	}

	~A()
	{
		free();
	}
};
```

**ВАЖНО**: Деструкторите на полетата **НЕ** трябва да се извикват експлицитно в деструктора на класа.

<h3>Домашно</h3>

**За всички задачи да се разпишат подробно класовете с всички добри практики, които сме изучавали!!**

*За целта на тези задачи може да ползвате готова имплементация на string(ваша или стандартната)*

*Позволено е да се добавят допълнителни полета и методи към класовете ако имате нужда от тях*

**Задача 1:** Да се създаде клас Author, в който да има следните полета:

- Собствено име - ***string***
- Последно име - ***string***
- Години - ***uint***
- Имейл - ***string***

Нека се реализират и тези функционалности:

- Getters
- Оператор <<

**Задача 2:** Да се създаде клас Book, в който да има следните полета:

- Име - ***string***
- Автори - ***Author[]***
- Цена - ***double***
- Текст - ***string***

Нека се реализират и тези функционалноти:

- Getters
- Метод, който казва дали има автор, чиито две имена съвпадат с подадените
- Метод за промяна на цената
- Метод за печатане на текстът
- Оператор <<


**Задача 3:** Да се реализира клас Library, който представлява колекция от двойки(pair) от книга и бройка.

- Книги - ***pair<Book, uint>[]***

Нека тя да има следните функционалности:

- Оператор [] - търси по име на книгата и връща бройката
- Да може да се взима книга от библиотеката
- Да може книгите да се сортират по азбучен ред
- Метод, който да връща всички книги, чиито автор е подаденият
- Метод, който казва дали дадена книга е налична
- Оператор <<
- Методи за запазване и четене от файл