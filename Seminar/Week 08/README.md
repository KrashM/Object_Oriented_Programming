<h1>Move семантики. Композиция на обекти. Шаблони.</h1>


<h3>lvalue vs rvalue</h3>

- **lvalue** - обект, който заема някакво конкретно място в паметта. (стойността в паметта може да се модифицира)
- **rvalue** - обект, който не е  *lvalue* .

<h5>Подаване на стойност по rvalue:</h5>

```c++
#include <iostream>
using std::cout;

void f(int& n)
{
	cout << n << endl;
}
int main()
{
	int number = 10;
	f(number); // OK!
	f(3);      // Error!
}
```
"Висящата" константа 3 **няма адрес в паметта**. За това подаването и като параметър на функцията f ще доведе до компилационна грешка. 

**&&** - за стойности без адрес в паметта

<h5>Пример за използването на lvalue:</h5>

```c++
#include<iostream>
using std::cout;

void f(int&& n)
{
	cout << n << endl;
}
int main()
{
	int number = 10;
	f(number); // Error!
	f(3);      // OK!
}
```

Тук грешката възниква при подаването на променлива, която **има адрес в паметта**.

<h3>Излишни копия?</h3>

Да разгледаме следният програмен фрагмент:
 
```c++
#include<iostream>
#include "Person.h"

Person createPerson(const char* name, int age)
{
	Person p(name, age);
	return p;
}

int main()
{
	Person p2("Petur",18);
	p2 = createPerson("Ivan", 23);
}
```

Тук се изпълняват следните функции на Person:

1. Конструктор на Person (за p2).
2. Конструктор за Person (на p).
3. Копиращ конструктор (за *return p*).
4. Деструктор (в края на функцията *createPerson*).
5. Оператор = (за *p2 = create...* ).
6. Деструктор (в края на функцията *main*).

Проблемът тук е, че правим излишни копия.  Обектът създаден в *createPerson* **се копира два пъти докато се присвои** на p2.

<h3>Move конструктор и move оператор =</h3>

За да избегнем излишните копия, може да "преместим" данните на обектът, който се създава във функцията, в данните на p2.

```c++
//Move constructor
Person::Person(Person&& rhs)
{
	name = rhs.name;
	age = rhs.age;

	rhs.name = nullptr;
}

//Move operator=
Person& Person::operator=(Person&& rhs)
{
	if (this != &rhs)
	{
		free();

		name = rhs.name;
		age = rhs.age;
		rhs.name = nullptr;
	}
	return *this;
}
```
 
Важно е да се обърне внимание, че тук данните **не се копират**, а се **местят**. Т.е приемаме, че rhs **няма да се използва след изпълнението на функцията**.

Сега при изпълнението на първоначално разгледания код:

1. Конструктор на Person (за p2).
2. Конструктор за Person (на p).
3. **Move конструктор** (за *return p*)
4. Деструктор (в края на функцията *createPerson*).
5. **Move oператор =** (за *p2 = create...* ).
6. Деструктор (в края на функцията *main*).

Т.е. тук си спестихме 2 копия за динамичната памет в Person.

<h3>Композиция</h3>

Композиция – класове като елементи на други класове (влагане на класове). Един клас може да включва в себе си обекти от други класове като член-данни. Когато обект от даден клас се дефинира, автоматично се извиква неговият конструктор. Ако класът съдържа полета, в неговия конструктор трябва да се укаже кои конструктори на полетата да се извикват.

<h5>Пример 1:</h5>

```c++
class A
{
	.
	.
	.
}
class B
{
	 int n;
	 A obj;
}
```

В тази ситуация се извикват **default** конструкторите на n и obj.

<h5>Пример 2:</h5>

```c++
class A
{
	A(int a, int b)
	.
	.
	.
}
class B
{
	B() : A(1, 2){}
	
	int n;
	A obj;
}
```

Тук A няма default-ен конструктор. Това означава, че в конструктора на B трябва да се извика **експлицитно** някой от неговите конструктори.

<h3>Композиция на обекти с динамична памет</h3>

Когато имаме композиция и в главния клас има динамично заделяне на памет, то трябва в реализацията на копи-конструктора и оператор=  **експлицитно** да се извикват копи-конструкторите и оператор= за всички полета (композирани обекти).

```c++
class B;

class A
{
	void copyFrom(A const &other)
	{
		arr = new int[other.size];
		for (int i = 0; i < other.size; i++)
			arr[i] = other.arr[i];
		size = other.size;
	}
	void free()
	{
		delete[] arr;
	}

public:
	B nestedObject;
	int* arr; //dynamic array
	size_t size; 
  
	A(int n) : size(n)
	{
		arr = new int[n];
	}
	A(const A& other) : nestedObject(other.objTest), size(other.size)
	{
		copyFrom(other);
	}
	A& operator=(const A& other)
	{
		
		if (this != &other)
		{
			free();
			nestedObject = other.nestedObject;
			size = other.size;
			copyFrom(other);
		}
		return *this;
	}

	~A()
	{
		free();
	}
};
```

**ВАЖНО**: Деструкторите на член-данните **НЕ** трябва да се извикват експлицитно в деструктора на класа.


<h3>Шаблони</h3>

Функция/клас, която работи не с променливи от някакъв дефиниран тип, а с абстрактни променливи, се нарича шаблонна функция/клас

```c++
#include <iostream>
using namespace std;

template <class T>
T sum(const T& a, const T& b)
{
    return a + b;
}

int main()
{
    int a = 4;
    int b = 9;
    cout << sum<int>(a, b) << endl;

    double c = 3.14;
    double d = 4.5;
    cout << sum<double>(c,d) << endl;
	
    return 0;
}
```

Компилаторът генерира т. нар. шаблонна функция, като замества параметрите на шаблона с типовете на съответните фактически параметри.

**Задача 1:**
Релизирайте структурата от данни опашка. Опашката трябва да работи с **произволни типове**. След като е добавен един елемент в края на опашката, той ще може да бъде извлечен (премахнат) единствено след като бъдат премахнати всички елементи преди него в реда, в който са добавени.

**Пример**:

```c++
int main()
{
	quene<int> q;
	q.push(3);
	q.push(5);
	q.push(10);

	cout << q.peek() << endl; //3
	q.pop();
	
	cout << q.peek() << endl; //5
	q.pop();

	cout << q.peek() << endl; //10
	q.pop();
	
	cout << q.isEmpty() << endl; //1	
}
```

**Задача 2:**
Създайте **шаблонна** опашка с k приоритета. При взимане на елемент от опашката трябва да се връща най-отдавна добавения елемент от тези с най-висок приоритет. **Важно:** Използвайте имплементацията на опашка от предната задача!
 
```c++
int main()
{
	kPriorityQueue<char> q(4); // 4 priorities - 0, 1, 2 и 3.
	
	q.push('A',0): //adds A with lowest priority: 0
	q.push('B',3);
	q.push('C',2);
	q.push('D',2);
	q.push('E',1);
	
	//q.push('F', 5); //error! No such priority!
	
	q.peek(); // B
	q.pop();
	
	q.peek(); // C
	q.pop();
	
	q.peek(); // D
	q.pop();
	
	q.peek(); // E
	q.pop();
	
	q.peek(); // A
	q.pop();
}
```