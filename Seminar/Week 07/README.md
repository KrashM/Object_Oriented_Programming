<h1>Unit testing</h1>

<h3>Дефиниция</h3>

Тестването на индивидуални софтуерни компоненти (units).

<h3>Какво представлява unit?</h3>

Unit е най-малката частица код, която може да се test-ва (или си заслужава да се тества).
Обикновено това може да е цял модул, но в повечето случаи е функция или метод.
Има 1 или няколко входа и **един** изход.

*Някои от по-известните framework-ове.*

|Language  |Test framework  |
|----------|----------------|
|C++       |CppUnit, doctest|
|C#        |NUnit, csUnit   |
|Java      |JUnit, Jtest    |
|JavaScript|JSUnit, QUnit   |

<h3>Какъв подход се използва за писане на unit тестове?</h3>

- най-използвания подход е test \- function \- expected value
- идеята е, че тестваме точно определена функционалност
- В помощ на unit test-овете влизат method stubs, mock objects, fakes и test harnesses, 
като идеята е, че те ни позволяват да се фокусираме над това, което тестваме
- Целта на unit test-овете е да изолират всяка една част на програмата и да покажат, че е коректна.
- Unit test-овете намират проблеми от рано в development процесът

<h3>Code coverage</h3>

Code coverage е измеримост на това, колко линии/блокове от нашия код са изпълнени, докато автоматизираните тестове текат.

<h3>White vs Black box testing</h3>

- Black Box Testing е метод на тестване, при който вътрешната структура/дизайн/имплементация на тестваният блок не са известни на този, който ги тества.
- White Box Testing е метод на тестване, при който вътрешната структура/дизайн/имплементация на тестваният блок са известни на този, който ги тества.

<h3>Кой пише unit тестове?</h3>

- Обикновенно самите софтуерни разработчици пишат тестовете си.

<h3>Ползи от unit тестове</h3>

- Unit тестовете осигурява сигурност при промяна/поддръжка на кода ни.
- Кодът става преизползваем, защото кодът става на модули, които могат да бъдат тествани отделно.
- Усилията, които ще ни коства да оправим дефект, засечен по време на тестване, са по-малко отколкото да оправим дефект, засечен на по-високо ниво.
- Debug-ването е по-лесно.

<h3>Примери от живота</h3>

Нека приемем, че имаме програма, която се състои от два unit-а и единственият тест, който правим е системен тест. (Пропускаме unit и integration тестовете.)
По време на тестване намираме bug в програмата. Сега, как ще определим от къде идва той?

Имаме следните варианти:

- В unit 1 ли е проблемът?
- В unit 2 ли е проблемът?
- И в двата unit-а ли има проблеми?
- Проблемът в интерфейса между двата unit-а ли е?
- Проблемът в тестът или в тест case-ът е?

<h3>Doctest</h3>

- **[Тук](https://github.com/doctest/doctest)** можете да намерите doctest framework-а.

<h3>Test Driven Development (TDD)</h3>

**Test-driven development (TDD)** е процес за софтуерна разработка, който разчита на повторението на един много кратък цикъл на разработка:

- Първо програмистът пише тест, който не минава, обаче дефинира желано подобрение или нова функционалност.
- След това пише код, който да минава тестът.
- И накрая рефакторира новият код, за да е по-четим.

TDD методът за работа може да се опише, като повторение на следните стъпки (показани на снимката):

- Избираме, коя функционалност трябва да се имплементира.
- Добавяме тест(ове) за избраната функционалност.
- Компилираме, тестваме и гледаме дали има някакви грешки.
- Пишем код, който да работи.
- Рефакторираме написаният код.
- Повтаряме тестовете, оправяме кода ако има грешни тестове.
- Commit-ваме промените.
- Отиваме на следващата функционалност и повтаряме стъпките.

![](https://i.ibb.co/61tp58D/TDD.png)

<h3>Как да организираме тестовете си</h3>

Тестовите случаи често се комбинират в тестови пакети според някакъв критерии - подобна функционалналност, различни употреби за една и съща функция, общи приспособления и т.н.

Добър начин по който да ги организираме:

- Тестовият случай трябва да тестваме само едно нещо;
- Тестовият случай трябва да е кратък;
- Тестът трябва да работи бързо, за да може да се прави често;
- Всеки тест трябва да работи независимо от другите тестове. Грешен или неправилно направен тестови случай не трябва да пречи на другите тестове;
- Тестовете не трябва да разчитат на поредността, в която са пуснати;

- Ако се хвърли някаква грешка от някой от тестовете, програмата ще приключи и няма как да го спрем;
- Няма как да направим тест, който проверява конкретна подсистема на тестваният unit;

<h3>Mocking</h3>

В unit testing-а, mock objects могат да симулират поведението на комплекси обекти, които бихме използвали в реална ситуация. Ако имаме някое от следните характеристики за нашите обекти, mock обект би бил подходящ:

- Връща недетерминистични резултати (времето сега, температурата навън);
- Има ситации, които са трудни за пресъздаване (network error);
- Бавна инициализация (цяла база данни);
- Още не съществува или може да промени поведението си;
- Трябва да добави информация и методи, само заради тестоването (а не за своята задача);

<h3>Домашно</h3>

***За всички задачи да бъдат напиасни тестове със 100% code coverage***

**Задача 1**

1. Да се дефинира клас Dictionary, който представлява тълковен речник. Нека речникът се състои от двойки дума\-тълкуване. В един речник не може да има повече от 500 такива двойки.
- да се дефинира подходящ клас, описващ една двойка дума тълкувание със следните методи
    - `init(const char*, const char*)` - инициализира структурата
    - `copy()` - връща нова структура, копие на оригиналната
    - `print()` - принтира двойката на екрана по подходящ начин
    - `deleteDynamic()` - зачиства динамичната памет
- за класа `Dictionary` да се дефинират:
    - `init(Record*, int)` - инициализира речника с масив от двойки
    - `print()` - принтира съдържанието на речника
    - `add(const Record&)` - добавя нова двойка към речника
    - `remove(const char*)` - премахва дадена двойка, като търсенето става по думата
    - `findMeaning(const char*)` - връща значението на дадена дума
    - `getByIndex(int index)` - връща значението на двойка с номер index
    - `sort()` - сортира двойките лексикографски по първи член на двойката (не по значението)
    - `deleteDynamic()` - обичайното 

**Задача 2** 

Да се създаде

```enum class Position {JUNIOR_DEV, DEV, SENIOR_DEV, QA, MANAGER};```

Да се създаде структура `Developer` със следните полета:
- mId - идентификационен номер в компанията. Представлява случайно генерирано 4-цифрено число.
- mFirstName;
- mLastName;
- mPosition - позиция, която заема. Една от константите Position.

Да се реализират функции:
- за инициализация на полетата на developer;
- за зачистване на диманичната памет  на developer;
- за записване на Developer във файл. При записване във файл developer-a да се добавя на края на съществуващия файл;
- за четене на полетата на Developer от файл;
- за принтиране на стандартния изход. Използвайте записването във файл.

Помислете как можете да добавите поле на Developer, което представлява прекия мениджър на developer-a и може да се заема само от друг Developer, чиято позиция е Manager.

П.П. Знанията за решаване на тази задача ще дойдат малко по-късно.

<h3>Допълнение</h3>

Напишете тестове за класовете `Vector` и `String` от миналата седмица.