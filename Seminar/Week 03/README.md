<h1>Методи. Аргументът this. Класове. Модификатори за достъп. Капсолация.</h1>

<h3>Методи</h3>

Методите са функции, които работят с данните на обекта от дадена структура/клас.

<h5>Нека разгледаме следният случай:</h5>

```c++
#include <iostream>

struct Point
{
	int x;
	int y;
};

bool isInFirstQuadrant(const Point& p)
{
	return p.x >= 0 && p.y >= 0;
}

void revert(Point& p)
{
	p.x = -p.x;
	p.y = -p.y;
}

int main()
{
	Point p1 = {3, 4};
	Point p2 = {-9, 8};
    revert(p2);
	std::cout << isInFirstQuadrant(p1) << std::endl;
	std::cout << isInFirstQuadrant(p2) << std::endl;
}
```
 
<h5>Може функциите да бъдат методи:</h5>
 
```c++
#include <iostream>

struct Point
{
	int x;
	int y

	bool isInFirstQuadrant() const
	{
		return x >= 0 && y >= 0;
	}
	
	void revert()
	{
		x = -x;
		y = -y;
	}
};

int main()
{
	Point p1 = {3, 4};
	Point p2 = {-9, 8};
    p2.revert();
	std::cout << p1.isInFirstQuadrant() << std::endl;
	std::cout << p2.isInFirstQuadrant() << std::endl;
}
```

**Методите**:
- Работят с данните на класа.
- Извикват се с обект на класа.
- Компилаторът преобразува всеки **метод** на дадена структура в обикновена функция с уникално име и един допълнителен параметър - **указател към обекта**.

**Константни методи**:
- Не променят полетата на класа.
- Оказва се чрез записването на ключовата  дума **const** в края на заглавието в дефиницията им.
- Могат да се извикват от константни обекти.

<h3>this</h3>

Указателят `this` е указател към текущения обект, с който работим. Той е неявен параметър на всички методи на класа.

Компилаторът транслира всички извиквания на методи по следния начин.

`p1.print(); → print(&p1);`

<h3>Класове</h3>

В обектно ориентираното програмиране класът е шаблон за създаване на обекти (структури от данни), който дава начални стойности за състоянието на обекта (член променливи или още полета) и имплементация на поведението на обекта (член функции или още методи).

<h3>Обекти на класът не могат да бъдат част от полетата на класът</h3>

```c++
// Не
class Person
{
    Person name;
    int age;
};
```

```c++
// Да
class Person
{
    Person* name;
    int age;
};
```

Това е поради фактът, че при първият пример, размерът на `Person` ще бъде размерът на `Person` + размерът на `int`. (Което довежда до невъзможност за изчисляване на размерът)

Във вторият пример, name е тип указател, което е с фиксиран размер `(4b/8b)`, което ни дава фиксиран размер на `Person`.

<h3>Модификатори за достъп</h3>

Едно от основните свойства на обектно ориентираното програмиране е скриването на данни (data hiding).

Можем да ограничим достъпа до полетата на един клас, за да предотвратим достъпа на други функции или класове до тях. По този начин ги предпазваме от (не)умишлени промени, когато такива не искаме да има.

Също е важно да дадем достъп до основните методи на класа, които да манипулират данните имплицитно.

Модификаторите за достъп ни позволяват да определим кои членове на класа да са достъпни за други класове и функции и кои не са.

| Specifiers | Same Class |	Derived Class |	Outside Class |
|------------|------------|---------------|---------------|
| `public`   | Yes        |	Yes           | Yes           |
| `private`  | Yes        | No            | No            |
| `protected`| Yes        | Yes           | No            |

**Забележка**: По подразбиране полетата в класовете са `private`, освен ако не е оказано друго, докато по подразбиране полетата в структурите са `public`.

<h5>Модификатор за достъп public</h5>

- Ключовата дума **public** се използва, за да създадем публични членове(полета и методи).
- Публичните членове са достъпни, навсякъде в нашата програма.

```c++
#include <iostream>

// define a class
class Person {

    // public elements
    public:
        int age;

        void displayAge() {
            std::cout << "Age = " << age << std::endl;
        }
};

int main() {
    // declare a class object
    Person obj1;

    std::cout << "Enter your age: ";

    // store input in age of the obj1 object
    std::cin >> obj1.age;

    // call class function
    obj1.displayAge();

    // this is generally a bad approach since we don't want to modify age directly
}
```

<h5>Модификатор за достъп private</h5>

- Ключовата дума **private** се използва, за да създаваме скрити членове(полета и методи).
- Скритите членове могат да бъдат достъпвани, само от самия клас.
- Приятелските класове и функции също имат достъп до тези членове.

```c++
#include <iostream>

// define a class
class Person {
    private:
        int age = 0;

    public:
        void displayAge() {
            std::cout << "Age = " << age << std::endl;
        }

        void birthday() {
            age++;
        }
};

int main() {
    // declare a class object
    Person obj1;
    // error
    // std::cin >> obj1.age;

    obj1.birthday();

    // call class function
    obj1.displayAge();
}
```

<h5>Модификаторът за достъп protected</h5>

- Ключовата дума protected се използва, за да създаваме защитени членове(полета и методи).
- Защитените членове могат да бъдат достъпвани, от самия клас и неговите наследници.
- Ще разглеждаме модификатора protected след като вземем наследяване.

<h3>Енкапсулация</h3>

Енкапсулацията е процес на имплементационно ниво. Тя се използва, за да се постигнат две неща, съвкупност от функционалност и данни, под една единица и дискретност на употребата им. Това се прави, за да се избегне нежелано поведение.

<h5>Пример за get-ъри и set-ъри:</h5>

```c++
#include <iostream>
using namespace std;

class Student 
{
private:
	int grade;
	int age;
public:
	int getGrade()
	{
		return grade;
	}
	int getAge()
	{
		return age;
	}
	void setGrade(int grade)
	{
		if(grade >= 2 && grade <= 6)
			this->grade = grade;
	}
	int setAge(int age)
	{
		if(age >= 0)
			this->age = age;
	}
};

int main()
{
	while(...)
	{
		Test t;// Object is created 
		if(...)
		{
			Test t2; // Object is created 

		}// Object is destroyed (t2)

	}//Object is destroyed (t)
}
```

<h3>Домашно</h3>

**!!!Важно!!!**
Нека домашните да се качват в [този](https://drive.google.com/drive/folders/1t6Zqfk5bGzzl8G2Z5mIfVSm6WiA4QU6A?usp=sharing) drive.

**Задача 1:** Да се направи клас Complex, който да представя комплексно число. Класът да има следните функционалности:

- get-ери за всички полета
- set-ери за всички полета
- метод print, който извежда комплексното число на екрана

Да се реализира функции, които приемат две комплексни числа и правят следните операции върху тях:

- събиране
- изваждане
- умножение

**Забележка** Функциите трябва да връщат нов обект от тип Complex.

**Задача 2:** Да се направи клас Car, който да съдържа полета за мощност, газ и изминато разстояние. При създаване на обекта мощността трябва да е 90 конски сили, газта и разстоянието да са занулени. Да се реализират следните функционалности за този клас:

- get-ери за 3те полета
- метод upgrade, която увеличава конските сили с 15, но техният максимум е 150
- метод fill, който зарежда колата на 100%
- метод drive, който кара колата с подадените км като разстояние

**Забележка** 1км каране хаби конските сили / 15 процента от газта.